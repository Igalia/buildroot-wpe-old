From 65415024f9bb719fe5d1bd8b8f9315a5294cef97 Mon Sep 17 00:00:00 2001
From: George Kiagiadakis <george.kiagiadakis@collabora.com>
Date: Thu, 1 Dec 2016 18:23:50 +0100
Subject: [PATCH] omxvideodec: add a signals-premature-eos hack for egl_render

egl_render seems to have a bug and signals EOS before it has finished
pushing out all data; this hack simply makes acquire_buffer() wait
a bit more before signalling EOS, in case egl_render decides to spit
out some more data.

https://bugzilla.gnome.org/show_bug.cgi?id=741856
---
 omx/gstomx.c         | 20 +++++++++++++++++---
 omx/gstomx.h         |  5 +++++
 omx/gstomxvideodec.c |  3 ++-
 3 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/omx/gstomx.c b/omx/gstomx.c
index e65409d..bb3cecd 100644
--- a/omx/gstomx.c
+++ b/omx/gstomx.c
@@ -1235,6 +1235,7 @@ gst_omx_port_acquire_buffer (GstOMXPort * port, GstOMXBuffer ** buf)
   GstOMXComponent *comp;
   OMX_ERRORTYPE err;
   GstOMXBuffer *_buf = NULL;
+  gint64 timeout = GST_CLOCK_TIME_NONE;
 
   g_return_val_if_fail (port != NULL, GST_OMX_ACQUIRE_BUFFER_ERROR);
   g_return_val_if_fail (!port->tunneled, GST_OMX_ACQUIRE_BUFFER_ERROR);
@@ -1251,6 +1252,11 @@ gst_omx_port_acquire_buffer (GstOMXPort * port, GstOMXBuffer ** buf)
 retry:
   gst_omx_component_handle_messages (comp);
 
+  /* If we are in the case where we waited for a buffer after EOS,
+   * make sure we don't do that again */
+  if (timeout != -1)
+    timeout = -2;
+
   /* Check if the component is in an error state */
   if ((err = comp->last_error) != OMX_ErrorNone) {
     GST_ERROR_OBJECT (comp->parent, "Component %s is in error state: %s",
@@ -1322,8 +1328,15 @@ retry:
       goto done;
     }
 
-    ret = GST_OMX_ACQUIRE_BUFFER_EOS;
-    goto done;
+    if (comp->hacks & GST_OMX_HACK_SIGNALS_PREMATURE_EOS && timeout != -2) {
+      timeout = 33 * GST_MSECOND;
+
+      GST_DEBUG_OBJECT (comp->parent, "%s output port %u is EOS but waiting "
+          "in case it spits out more buffers", comp->name, port->index);
+    } else {
+      ret = GST_OMX_ACQUIRE_BUFFER_EOS;
+      goto done;
+    }
   }
 
   /* 
@@ -1339,7 +1352,8 @@ retry:
   if (g_queue_is_empty (&port->pending_buffers)) {
     GST_DEBUG_OBJECT (comp->parent, "Queue of %s port %u is empty",
         comp->name, port->index);
-    gst_omx_component_wait_message (comp, GST_CLOCK_TIME_NONE);
+    gst_omx_component_wait_message (comp,
+        timeout == -2 ? GST_CLOCK_TIME_NONE : timeout);
 
     /* And now check everything again and maybe get a buffer */
     goto retry;
diff --git a/omx/gstomx.h b/omx/gstomx.h
index bc9bdd0..60a315b 100644
--- a/omx/gstomx.h
+++ b/omx/gstomx.h
@@ -45,6 +45,11 @@
 # endif
 #endif
 
+/* If the component may signal EOS before it has finished pushing
+ * out all of its buffers. Happens with egl_render on the rpi.
+ */
+#define GST_OMX_HACK_SIGNALS_PREMATURE_EOS                            G_GUINT64_CONSTANT (0x0000000000000400)
+
 #include <OMX_Core.h>
 #include <OMX_Component.h>
 
diff --git a/omx/gstomxvideodec.c b/omx/gstomxvideodec.c
index 95d10c9..9dd44ef 100644
--- a/omx/gstomxvideodec.c
+++ b/omx/gstomxvideodec.c
@@ -205,7 +205,8 @@ gst_omx_video_dec_open (GstVideoDecoder * decoder)
   GST_DEBUG_OBJECT (self, "Opening EGL renderer");
   self->egl_render =
       gst_omx_component_new (GST_OBJECT_CAST (self), klass->cdata.core_name,
-      "OMX.broadcom.egl_render", NULL, klass->cdata.hacks);
+      "OMX.broadcom.egl_render", NULL,
+      klass->cdata.hacks | GST_OMX_HACK_SIGNALS_PREMATURE_EOS);
 
   if (!self->egl_render)
     return FALSE;
-- 
2.10.2

